%Especificacion
\documentclass[12pt]{article}

%Paquetes
\usepackage[left=2.5cm,right=2.5cm,top=3cm,bottom=3cm,letterpaper]{geometry}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,activeacute]{babel}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{scrextend}
\usepackage{outlines}
\usepackage{graphicx}

%Preambulo
\title{Compiladores\\ Proyecto 1}
\author{Carlos Acosta \qquad Karla Esquivel \\ Yuan Yuan \qquad Luis Mayo \\ Andrea González}
\date{Facultad de Ciencias UNAM \\ 2017-2}
\setlength\parindent{0pt}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Preliminares}
\subsection{El lenguaje}
Definimos la gramática de nuestro lenguaje con mucha inspiración de los lenguajes que ya conocíamos, tratando de tomar aspectos de la sintaxis de estos, pero con nuestras propias propuestas también. La base de nuestra gramática era del programa de la calculadora que vimos en clase y la grámatica del analizador sintáctico de descenso recursivo de la tarea. Agregamos posteriormente definiciones de funciones y algunas estructuras de control de flujo, además de expresiones booleanas. Este proceso nos llevó a pensar en cuáles eran las funcionalidades mínimas que tendría nuestro lenguaje. \\

Una decisión que nos resultó difícil tomar fue cómo distinguir el final de las estructuras de control y funciones, debido a que no estaba en nuestras intenciones utilizar corchetes. Así que uno de los tokens importantes era para terminar una estructuras de control y, tomando inspiración de lenguajes que determinan el final de un bloque con un un lexema similar al del inicio del bloque como bash, terminamos eligiendo el símbolo `$\sim$'\; junto al nombre de la estructura para indicar la terminación de ésta. \\

Elegir el resto de los tokens no fue difícil. Era sólo una cuestión de cubrir todas las entradas posibles que nuestro programa aceptaría, y cual podría ser cada símbolo. Los números eran una opción obvia por la calculadora (lo que elegimos representar por un flotante y entero para soportar todas las posibilidades, como decimales). Además de eso, incluimos cadenas, así como varios otros símbolos comunes en lenguajes actuales como \texttt{<=}.

\subsection {La gramática}
\subsection{Categorias sintácticas y tokens}
Ver número 2.


\section{Definición de la gramática formal}

Sea $G$ nuestra gramática de expresiones aritméticas. Definiremos $G$, como la 4-tupla: $G = (N,T,P,S)$, con $N,T,P$ conjuntos y $S \in N$ el símbolo de la producción inicial.
A continuación, se muestran los conjuntos que la conforman:\\ \\
\texttt{ 
N = \{S, Fprog, Fprog', Prog, Prog', Inst, Fundef, Fundef', Return, While, Fun, Fdparams, Fparams, Param, Cond, Sig, Expr, Bexp, Bterm, Beq, Bcom, Expr', Term, Factor, Bool, Num, Decimal, Entero, Digito, Asig, Asig', Easig, Id, pos, Carac, Letra, Tipo\}
}\\

\texttt{
T = \{., :, ;, +, -, /, *, =, \_, ==, >, <, >=, <=, and, or, not, (, ), fun, while, cond, $\sim$fun, $\sim$while, $\sim$cond, int, float, bool, void, |, 0, 1,..., 9, a, ..., z, A, ..., Z\}  \footnote{En la gramática utilizaremos ``!'' para representar a ``|'' con el propósito de no confundir el símbolo terminal ``|'' con la separación las ramificaciones en las producciones.}
}\\

\texttt{
P = \{
\begin{addmargin}[2.5em]{0em}
    S $\to$ Fprog\\
    Fprog $\to$ Fprog Fprog' | Fprog' \\
    Fprog' $\to$ Asig'; | Fundef \\
    Prog $\to$ Prog Prog' | Prog' \\
    Prog' $\to$ Cond | While | Inst; | Fun; \\
    Inst $\to$ Expr | Asig\\
    Fundef $\to$ fun Id (Fdparams) Fundef' | fun Id ( ) Fundef' \\
    Fundef' $\to$ Tipo : Prog Return; $\sim$fun | void : Prog $\sim$fun \\
    Return $\to$ return Expr | return Fun \\
    While $\to$ while Expr : Prog $\sim$while\\    
    Fun $\to$ Id (Fparams) | Id ( )\\
    Fdparams $\to$ Fdparams, Tipo Id | Tipo Id \\
    Fparams $\to$ Fparams, Param | Param  \\
    Param $\to$ Expr \\
    Cond $\to$ cond Expr : Sig $\sim$cond \\
    Sig $\to$ Prog ! Expr : Sig | Prog ! default : Prog | Prog \\
    Expr $\to$ Bexp \\ 
    Bexp $\to$ Bexp or Bterm | Bterm \\ 
    Bterm $\to$ Bterm and Beq | Beq \\ 
    Beq $\to$ Beq == Bcomp | Beq != Bcomp | Bcomp \\ 
    Bcomp $\to$ Bcomp < Expr' | Bcomp > Expr' | Bcomp <= Expr' | Bcomp >= Expr' | Expr' \\ 
    Expr' $\to$ Expr' + Term | Expr' - Term | Term \\
    Term $\to$ Term * Factor | Term / Factor | Factor \\    
    Factor $\to$ Id | Num | (Expr) | - Factor | not Factor | Bool \\
    Bool $\to$ true | false \\
    Num $\to$ Entero Decimal \\
    Decimal $\to$ . Entero | $\varepsilon$ \\
    Entero $\to$ Digito | Digito Entero \\
    Digito $\to$ 0 | 1 | 2 | ... | 9 \\
    Asig $\to$  Easig | Asig' \\
    Asig' $\to$ Tipo Easig \\
    Easig $\to$ Id = Expr | Id = Fun \\
    Id  $\to$ Letra Pos | Letra \\
    Pos  $\to$ Pos Carac | Carac \\
    Carac $\to$ Letra | \_ | Digito \\
    Letra $\to$ a | b | ... | z | A | B | ... | Z \\
    Tipo $\to$ int | float | bool \\
\end{addmargin}
\}
}

%razomiento para gramática va aquí 
\section{Categorías sintácticas y definición de tokens}
A continuación se describen las categorías sintácticas identificadas en la grámatica y los tokens\footnote{Por convención, los identificadores de los tokens (átomos) están escritos exclusivamente en mayúsculas.} que la componen:\\
\subsection{Valores:}
\begin{itemize}
  \item ENTERO, números enteros.
    \item FLOTANTE, números de punto flotante.
    \item BOOLEANO, define un valor booleano.
      \begin{itemize}
      \item TRUE, valor booleano de verdadero.
      \item FALSE, valor booleano de falso.
      \item ID, identificadores de variables y funciones.
      \end{itemize}
\end{itemize}
\subsection{Operadores:}
\begin{itemize}
  \item \textbf{Operadores binarios:}
  \begin{itemize}
  \item PLUS, suma para expresiones aritméticas.	
  \item MINUS, resta para expresiones aritméticas.
  \item MULT, producto para expresiones aritméticas.
  \item DIV, división para expresiones aritméticas.
  \item EQ, igualdad de dos expresiones.
  \item NEG, desigualdad de dos expresiones.
  \item AND, operador lógico $\land$ para expresiones booleanas.
  \item OR, operador lógico $\lor$ para expresiones booleanas.
  \item GREAT, operador $>$  para expresiones.
  \item LESS, operador $<$ para expresiones.
  \item GREATEQ, operador $\geq$ para expresiones.
  \item LESSEQ, operador $\leq$ para expresiones.
  \item ASIG, asignación de un valor a una variable.
  \end{itemize}
\item \textbf{Operadores unarios:}
  \begin{itemize}
  \item NOT, negación de un valor.
  \end{itemize}
\end{itemize}
\subsection{Estructuras de control:}
\begin{itemize}
 	\item COND, establece el inicio de un bloque de condicionales.
    \item ENDCOND, establece el final de un bloque de condicionales.
    \item DEFAULT, caso por defecto del bloque de condicionales, en caso de no cumplir con ninguna condición dada.
    \item WHILE, establece el inicio de un bloque de ciclo while.
    \item ENDWHILE, establece el final de un bloque de ciclo while.
    \item FUN, establece el inicio de un bloque de función.
    \item ENDFUN, establece el final de un bloque de función.
\end{itemize}
    \subsection{Conectores:}
    \begin{itemize}
 	\item LPAR, paréntesis izquierdo.
    \item RPAR, paréntesis derecho.
    \item SEMIC, punto y coma para señalar el final de cada sentencia.
    \item DOTDOT, dos puntos para señalar el inicio de un bloque.
    \item COMMA, coma para separar los parametros de una función y añadir legibilidad.
    \item PIPE, señala la declaración de un caso en el bloque de condicionales.
\end{itemize}


\section{Implementación del analizador léxico}
Se usó el generador de analizadores léxicos \textit{Flex} en su versión 2.6.3 para C++. \\
Para más información sobre la implementación del analizador léxico con \textit{Flex} se puede ver el archivo \texttt{lexer.lex} del directorio \texttt{src}.\\
\section{Implementación del analizador sintáctico \textit{Bottom-Up}}
Se utilizó la versión 3.0.4 del generador de analizadores sintácticos \textit{GNU Bison} para C++. \\
Dicha implementación está en el archivo \texttt{parser.y} del directorio \texttt{src/}



\subsection*{Instrucciones para ejecutar y compilar el código}

\subsubsection*{Para compilarlo:}

En cualquier sistema operativo basado en Unix basta con ejecutar \texttt{make} en el directorio \texttt{src} desde línea de comandos. 

\subsubsection*{Para ejecutarlo:} 

\begin{verbatim}
    ./kyc-ip <archivo>
\end{verbatim}
Donde \texttt{<archivo>} es el archivo con el código de entrada.

\subsubsection*{Ejemplo de entrada\footnote{El archivo de entrada que contiene este ejemplo se encuentra ubicado en la raíz del proyecto con el nombre de \textbf{\textit{ejemplo.kyc}}. }:}
\begin{verbatim}
fun hola ( int angel ) int : 
    angel = ( angel + 56 / 89.098 );
    bool adan = true or false and true;
    bool armando = false or var1;
    cond adan and armando:
         float c = 1 + 2 / (3.20 * 92);
         | (adan == armando) or (angel > 98.98):
               int x = 98.9;
               9 + 9;
         | default:
               x = f(adan, armando or true, angel + 98.09);            
    ~cond
    while true:
          int x = f2(angel, angel * (0.982 + 2.2) / -89);            
    ~while
    return 0;
~fun

fun adios() void :
    9 + 9;
    f(x);
~fun

int x = f(a, b, c + d);
bool b = false;
\end{verbatim}
\end{document}
