%Especificacion
\documentclass[12pt]{article}

%Paquetes
\usepackage[left=2cm,right=2cm,top=3cm,bottom=3cm,letterpaper]{geometry}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,activeacute]{babel}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{scrextend}
\usepackage{outlines}
\usepackage{graphicx}

%Preambulo
\title{Compiladores\\ Proyecto 1}
\author{Carlos Acosta \qquad Karla Esquivel \\ Yuan Yuan \qquad Luis Mayo \\ Andrea González}
\date{Facultad de Ciencias UNAM \\ 2017-2}
\setlength\parindent{0pt}

\begin{document}
\maketitle
\subsubsection*{1. Definición de la gramática}

Sea $G$ nuestra gramática de expresiones aritméticas. Definiremos $G$, como la 4-tupla: $G = (N,T,P,S)$, con $N,T,P$ conjuntos y $S$ el símbolo de la producción inicial.
A continuación, se muestran los conjuntos que la conforman:\\ \\
\texttt{ 
N = \{Expr, Expr', Asig, Term, Term', Factor, Num, Entero, Decimal, Digito, Var \}
}\\
\texttt{
T = \{., :, ;, +, -, /, *, =, \_, $\sim$, var, cond, !, 0, 1,..., 9, a, ..., z, A, ..., Z\}
}\\
\texttt{
P = \{
\begin{addmargin}[2.5em]{0em}
    S $\to$ Fprog\\
    Fprog $\to$ Fprog Fprog' | Fprog' \\
    Fprog' $\to$ Asig'; | Fundef \\
    Prog $\to$ Prog Prog' | Prog' \\
    Prog' $\to$ Cond | While | Inst; | Fun; \\
    Inst $\to$ Expr | Asig\\
    Fundef $\to$ fun Id (Fdparams) Tipo : Prog $\sim$fun\\
    While $\to$ while Expr : Prog $\sim$while\\    
    Fun $\to$ Id (Fparams)\\
    Fdparams $\to$ Fdparams, Tipo Id | Tipo Id \\
    Fparams $\to$ Fparams, Param | Param  \\
    Param $\to$ Expr \\
    Cond $\to$ cond Expr : Sig $\sim$cond \\
    Sig $\to$ Prog ! Expr : Sig | Prog ! default : Prog | Prog \\
    Expr $\to$ Bexp \\ 
    Bexp $\to$ Bexp or Bterm | Bterm \\ 
    Bterm $\to$ Bterm and Beq | Beq \\ 
    Beq $\to$ Beq == Bcomp | Beq != Bcomp | Bcomp \\ 
    Bcomp $\to$ Bcomp < Expr' | Bcomp > Expr' | Bcomp <= Expr' | Bcomp >= Expr' | Expr' \\ 
    Expr' $\to$ Expr' + Term | Expr' - Term | Term \\
    Term $\to$ Term * Factor | Term / Factor | Factor \\    
    Factor $\to$ Id | Num | (Expr) | - Factor | not Factor | Bool \\
    Bool $\to$ true | false \\
    Num $\to$ Entero Decimal \\
    Decimal $\to$ . Entero | $\varepsilon$ \\
    Entero $\to$ Digito | Digito Entero \\
    Digito $\to$ 0 | 1 | 2 | ... | 9 \\
    Asig $\to$  Easig | Asig' \\
    Asig' $\to$ Tipo Easig \\
    Easig $\to$ Id = Expr | Id = Fun \\
    Id  $\to$ Letra Pos | Letra \\
    Pos  $\to$ Pos Carac | Carac \\
    Carac $\to$ Letra | \_ | Digito \\
    Letra $\to$ a | b | ... | z | A | B | ... | Z \\
    Tipo $\to$ int | float | bool \\
\end{addmargin}
\}
}

%razomiento para gramática va aquí 
\subsubsection*{2. Identificar las categorías sintácticas y definir los tokens}
A continuación se describen las categorías sintácticas identificadas en la grámatica y los tokens que la componen:\\
\textbf{Nota:} Por convención, los identificadores de los tokens (átomos) están escritos exclusivamente en mayúsculas. 
\begin{outline}
\1 \textbf{Valores:}
	\2 ENTERO, números enteros.
    \2 FLOTANTE, números de punto flotante.
    \2 BOOLEANO, define un valor booleano.
    \3 TRUE, valor booleano de verdadero.
    \3 FALSE, valor booleano de falso.
    \3 ID, identificadores de variables y funciones.
\1 \textbf{Operadores:}
	\2 \textbf{Operadores binarios:}
		\3 PLUS, suma para expresiones aritméticas.	
    	\3 MINUS, resta para expresiones aritméticas.
    	\3 MULT, producto para expresiones aritméticas.
    	\3 DIV, división para expresiones aritméticas.
    	\3 EQ, igualdad de dos expresiones.
        \3 NEG, desigualdad de dos expresiones.
    	\3 AND, operador lógico $\land$ para expresiones booleanas.
    	\3 OR, operador lógico $\lor$ para expresiones booleanas.
    	\3 GREAT, operador $>$  para expresiones.
    	\3 LESS, operador $<$ para expresiones.
    	\3 GREATEQ, operador $\geq$ para expresiones.
        \3 LESSEQ, operador $\leq$ para expresiones.
        \3 ASIG, asignación de un valor a una variable.
 	\2 \textbf{Operadores unarios:}
    	\3 NOT, negación de un valor.
 \1 \textbf{Estructuras:}
 	\2 COND, establece el inicio de un bloque de condicionales.
    \2 ENDCOND, establece el final de un bloque de condicionales.
    \2 DEFAULT, caso por defecto del bloque de condicionales, en caso de no cumplir con ninguna condición dada.
    \2 WHILE, establece el inicio de un bloque de ciclo while.
    \2 ENDWHILE, establece el final de un bloque de ciclo while.
    \2 FUN, establece el inicio de un bloque de función.
    \2 ENDFUN, establece el final de un bloque de función.
 \1 \textbf{Conectores:}
 	\2 LPAR, paréntesis izquierdo.
    \2 RPAR, paréntesis derecho.
    \2 SEMIC, punto y coma para señalar el final de cada sentencia.
    \2 DOTDOT, dos puntos para señalar el inicio de un bloque.
    \2 COMMA, coma para separar los parametros de una función y añadir legibilidad.
    \2 PIPE, señala la declaración de un caso en el bloque de condicionales.
\end{outline}
\subsubsection*{3. Implementación del analizador léxico}
Se usó el generador de analizadores léxicos \textit{Flex} en su versión 2.6.3 para C++. \\
Para más información sobre la implementación del analizador léxico con \textit{Flex} se puede ver el archivo \texttt{lexer.lex} del directorio \texttt{src}.\\
\subsubsection*{4. Implementación del analizador sintáctico \textit{Bottom-Up}}
Se utilizó la versión 3.0.4 del generador de analizadores sintácticos \textit{GNU Bison} para C++. \\
Dicha implementación está en el archivo \texttt{parser.y} del directorio \texttt{src}


\subsection*{Razonamiento para la gramática}
\subsubsection*{Categorias sintácticas}
Ver número 2 arriba.
\subsubsection*{Tokens y la gramática}
Definimos la gramática de nuestro lenguaje con mucha inspiración de los lenguajes que ya conocíamos, tratando de tomar aspectos de la sintaxis de estos, pero con nuestras propias propuestas también. La base de nuestra gramática era del programa de la calculadora que vimos en clase y la grámatica del analizador sintáctico de descenso recursivo de la tarea. Agregamos posteriormente definiciones de funciones y algunas estructuras de control de flujo, además de expresiones booleanas. Este proceso nos llevó a pensar en las cuáles eran las funcionalidades mínimas que tendría nuestro lenguaje. \\

Por otro lado, una decisión que nos resultó difícil tomar fue cómo distinguir el final de las estructuras de control y funciones, debido a que no queríamos usar corchetes. Así que uno de los tokens importantes era para terminar una estructuras de control y, tomando inspiración del lenguaje moderno de PHP, terminamos eligiendo el símbolo "$\sim$" junto al nombre de la estructura para indicar la terminación de ésta. \\

Elegir el resto de los tokens no fue difícil. Era sólo una cuestión de cubrir todas las entradas posibles que nuestro programa aceptaría, y cual podría ser cada símbolo. Los números eran una opción obvia por la calculadora (lo que elegimos representar por un flotante y entero para soportar todas las posibilidades, como decimales). Además de eso, incluimos cadenas, así como varios otros símbolos comunes en las lenguas modernas como $\leq$

\subsection*{Instrucciones para ejecutar y compilar el código}

\subsubsection*{Para compilarlo:}

En cualquier sistema operativo basado en Unix basta con ejecutar \texttt{make} en el directorio \texttt{src} desde línea de comandos. 

\subsubsection*{Para ejecutarlo:} 

\texttt{./kyc-ip <archivo>}
\subsubsection*{Ejemplo de salida}
\begin{verbatim}
fun hola ( int angel ) int : 
    angel = ( angel + 56 / 89.098 );
    bool adan = true or false and true;
    bool armando = false or var1;
    cond adan and armando:
         float c = 1 + 2 / (3.20 * 92);
         | (adan == armando) or (angel > 98.98):
               int x = 98.9;
               9 + 9;
         | default:
               x = f(adan, armando or true, angel + 98.09);            
    ~cond
    while true:
          int x = f2(angel, angel * (0.982 + 2.2) / -89);            
    ~while
~fun

int x = f(a, b, c + d);
bool b = false;
\end{verbatim}
\end{document}